MISP or 'Mud Lisp' is a scripting language designed for my current un-named mud engine. Every aspect of the mud, from command matching to logging in, is written in MISP. The mud engine presents a multi-user terminal to a MISP interpretter. The engine provides only minimal tools to this emulator - a simple verb matching mechanism, an 'action' queue, and a dead-simple on disc 'database'. The design is somewhat inspired by LPMud, which presents a similar environment for LPC. Everything that makes the mud a mud is implemented in MISP, and thus is part of the database. Individual MISP source files (or 'Database Objects' - they are one and the same) can be reloaded on-the-fly, allowing you to make sweeping changes without shutting down and restarting the mud. (Be careful, though. It's certainly possible to break it.)

A MISP script is a list of parenthesized nodes separated by text, whitespace, or nothing at all. Each script is a database object. At the top level, things in between nodes are discarded and can be used for comments. Comments between /* and */ are also supported. A node is (usually) a function call. The first item inside the node is the function to call, followed by any number of arguments. (function_name argument argument argument) The default database offers the 'functions' command which will list all the functions currently defined in the emulator. 
Some prefixes change the behavior of nodes. ^ makes the node a list. It won't be evaluated (but all of it's arguments will be). Prefix the node with * and it won't be evaluated at all. The result is a parse tree. Some functions expect a parse tree as an argument and will evaluate it themselves. $ expands a node into the argument list of it's parent node. The node is still evaluated, so given (bar $(foo)), if foo is a list or a function that returns a list, the first argument to bar will be the first item in the list, and the second argument will be the second item, and so forth.
If the first item in a node isn't a function (and there are no prefixes) the result of the node is the item.
The language also supports string expressions - very handy for a mud. A string is surrounded in quotes "like this" and can have nodes embedded in it. The nodes will be converted to a string. The result is a single string. Prefix a string expression with ^ and the result is instead an un-evaluated string expression. From the 'get' command in the default database, here is an example of a string expression. "(actor:short) takes (object:a) from (preposition) (from:the)."
Arguments can also be tokens. Tokens are any sequence of characters that doesn't start with a digit and doesn't contain any spaces or other control characters (like ^*$ and (). There are two contexes for tokens. The first, the token is by itself, is a variable name. The evaluator will look first for built in 'special' variables, then for variables and function arguments, and finally for functions. Prefix a token with @ and the evaluator will look for the function even if a variable with the same name has hidden it. The second context is in the second part of member access where the token is used directly to lookup the member and not evaluated first.
Some functions return script objects. Script objects have named members accessible using the . or : operators. Expression.expression, with no spaces. If the second expression is a token it's used directly, otherwise it will be evaluated and converted to a string. The . operator will return the member as-is. The : operator will evaluate it and return the result. 